# coding: utf-8

"""
    Zitadel SDK

    The Zitadel SDK is a convenience wrapper around the Zitadel APIs to assist you in integrating with your Zitadel environment. This SDK enables you to handle resources, settings, and configurations within the Zitadel platform.

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from zitadel_client.models.settings_service_multi_factor_type import SettingsServiceMultiFactorType
from zitadel_client.models.settings_service_passkeys_type import SettingsServicePasskeysType
from zitadel_client.models.settings_service_resource_owner_type import SettingsServiceResourceOwnerType
from zitadel_client.models.settings_service_second_factor_type import SettingsServiceSecondFactorType
from typing import Optional, Set
from typing_extensions import Self

class SettingsServiceLoginSettings(BaseModel):
    """
    SettingsServiceLoginSettings
    """ # noqa: E501
    allow_username_password: Optional[StrictBool] = Field(default=None, description="defines if a user is allowed to log in with username and password", alias="allowUsernamePassword")
    allow_register: Optional[StrictBool] = Field(default=None, description="defines if a person is allowed to register a user on this organization", alias="allowRegister")
    allow_external_idp: Optional[StrictBool] = Field(default=None, description="defines if a user is allowed to add a defined identity provider. E.g. Google auth", alias="allowExternalIdp")
    force_mfa: Optional[StrictBool] = Field(default=None, description="defines if a user MUST use a multi-factor to log in", alias="forceMfa")
    passkeys_type: Optional[SettingsServicePasskeysType] = Field(default=SettingsServicePasskeysType.PASSKEYS_TYPE_NOT_ALLOWED, alias="passkeysType")
    hide_password_reset: Optional[StrictBool] = Field(default=None, description="defines if password reset link should be shown in the login screen", alias="hidePasswordReset")
    ignore_unknown_usernames: Optional[StrictBool] = Field(default=None, description="defines if unknown username on login screen directly returns an error or always displays the password screen", alias="ignoreUnknownUsernames")
    default_redirect_uri: Optional[StrictStr] = Field(default=None, description="defines where the user will be redirected to if the login is started without app context (e.g. from mail)", alias="defaultRedirectUri")
    password_check_lifetime: Optional[StrictStr] = Field(default=None, description="Defines after how much time the user has to re-authenticate with the password.", alias="passwordCheckLifetime")
    external_login_check_lifetime: Optional[StrictStr] = Field(default=None, description="Defines after how much time the user has to re-authenticate with an external provider.", alias="externalLoginCheckLifetime")
    mfa_init_skip_lifetime: Optional[StrictStr] = Field(default=None, description="Defines after how much time the mfa prompt will be shown again.", alias="mfaInitSkipLifetime")
    second_factor_check_lifetime: Optional[StrictStr] = Field(default=None, description="Defines after how long the second factor check is valid.", alias="secondFactorCheckLifetime")
    multi_factor_check_lifetime: Optional[StrictStr] = Field(default=None, description="Defines how long the multi-factor check is valid.", alias="multiFactorCheckLifetime")
    second_factors: Optional[List[SettingsServiceSecondFactorType]] = Field(default=None, alias="secondFactors")
    multi_factors: Optional[List[SettingsServiceMultiFactorType]] = Field(default=None, alias="multiFactors")
    allow_domain_discovery: Optional[StrictBool] = Field(default=None, description="If set to true, the suffix (@domain.com) of an unknown username input on the login screen will be matched against the org domains and will redirect to the registration of that organization on success.", alias="allowDomainDiscovery")
    disable_login_with_email: Optional[StrictBool] = Field(default=None, description="defines if the user can additionally (to the login name) be identified by their verified email address", alias="disableLoginWithEmail")
    disable_login_with_phone: Optional[StrictBool] = Field(default=None, description="defines if the user can additionally (to the login name) be identified by their verified phone number", alias="disableLoginWithPhone")
    resource_owner_type: Optional[SettingsServiceResourceOwnerType] = Field(default=SettingsServiceResourceOwnerType.RESOURCE_OWNER_TYPE_UNSPECIFIED, alias="resourceOwnerType")
    force_mfa_local_only: Optional[StrictBool] = Field(default=None, description="if activated, only local authenticated users are forced to use MFA. Authentication through IDPs won't prompt a MFA step in the login.", alias="forceMfaLocalOnly")

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SettingsServiceLoginSettings from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SettingsServiceLoginSettings from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "allowUsernamePassword": obj.get("allowUsernamePassword"),
            "allowRegister": obj.get("allowRegister"),
            "allowExternalIdp": obj.get("allowExternalIdp"),
            "forceMfa": obj.get("forceMfa"),
            "passkeysType": obj.get("passkeysType") if obj.get("passkeysType") is not None else SettingsServicePasskeysType.PASSKEYS_TYPE_NOT_ALLOWED,
            "hidePasswordReset": obj.get("hidePasswordReset"),
            "ignoreUnknownUsernames": obj.get("ignoreUnknownUsernames"),
            "defaultRedirectUri": obj.get("defaultRedirectUri"),
            "passwordCheckLifetime": obj.get("passwordCheckLifetime"),
            "externalLoginCheckLifetime": obj.get("externalLoginCheckLifetime"),
            "mfaInitSkipLifetime": obj.get("mfaInitSkipLifetime"),
            "secondFactorCheckLifetime": obj.get("secondFactorCheckLifetime"),
            "multiFactorCheckLifetime": obj.get("multiFactorCheckLifetime"),
            "secondFactors": obj.get("secondFactors"),
            "multiFactors": obj.get("multiFactors"),
            "allowDomainDiscovery": obj.get("allowDomainDiscovery"),
            "disableLoginWithEmail": obj.get("disableLoginWithEmail"),
            "disableLoginWithPhone": obj.get("disableLoginWithPhone"),
            "resourceOwnerType": obj.get("resourceOwnerType") if obj.get("resourceOwnerType") is not None else SettingsServiceResourceOwnerType.RESOURCE_OWNER_TYPE_UNSPECIFIED,
            "forceMfaLocalOnly": obj.get("forceMfaLocalOnly")
        })
        return _obj


