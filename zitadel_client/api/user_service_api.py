# coding: utf-8

"""
    Zitadel SDK

    The Zitadel SDK is a convenience wrapper around the Zitadel APIs to assist you in integrating with your Zitadel environment. This SDK enables you to handle resources, settings, and configurations within the Zitadel platform.

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from zitadel_client.models.user_service_add_human_user_request import UserServiceAddHumanUserRequest
from zitadel_client.models.user_service_add_human_user_response import UserServiceAddHumanUserResponse
from zitadel_client.models.user_service_add_idp_link_request import UserServiceAddIDPLinkRequest
from zitadel_client.models.user_service_add_idp_link_response import UserServiceAddIDPLinkResponse
from zitadel_client.models.user_service_add_otp_email_response import UserServiceAddOTPEmailResponse
from zitadel_client.models.user_service_add_otpsms_response import UserServiceAddOTPSMSResponse
from zitadel_client.models.user_service_create_invite_code_request import UserServiceCreateInviteCodeRequest
from zitadel_client.models.user_service_create_invite_code_response import UserServiceCreateInviteCodeResponse
from zitadel_client.models.user_service_create_passkey_registration_link_request import UserServiceCreatePasskeyRegistrationLinkRequest
from zitadel_client.models.user_service_create_passkey_registration_link_response import UserServiceCreatePasskeyRegistrationLinkResponse
from zitadel_client.models.user_service_deactivate_user_response import UserServiceDeactivateUserResponse
from zitadel_client.models.user_service_delete_user_response import UserServiceDeleteUserResponse
from zitadel_client.models.user_service_get_user_by_id_response import UserServiceGetUserByIDResponse
from zitadel_client.models.user_service_human_mfa_init_skipped_response import UserServiceHumanMFAInitSkippedResponse
from zitadel_client.models.user_service_list_authentication_factors_response import UserServiceListAuthenticationFactorsResponse
from zitadel_client.models.user_service_list_authentication_method_types_response import UserServiceListAuthenticationMethodTypesResponse
from zitadel_client.models.user_service_list_idp_links_request import UserServiceListIDPLinksRequest
from zitadel_client.models.user_service_list_idp_links_response import UserServiceListIDPLinksResponse
from zitadel_client.models.user_service_list_passkeys_response import UserServiceListPasskeysResponse
from zitadel_client.models.user_service_list_users_request import UserServiceListUsersRequest
from zitadel_client.models.user_service_list_users_response import UserServiceListUsersResponse
from zitadel_client.models.user_service_lock_user_response import UserServiceLockUserResponse
from zitadel_client.models.user_service_password_reset_request import UserServicePasswordResetRequest
from zitadel_client.models.user_service_password_reset_response import UserServicePasswordResetResponse
from zitadel_client.models.user_service_reactivate_user_response import UserServiceReactivateUserResponse
from zitadel_client.models.user_service_register_passkey_request import UserServiceRegisterPasskeyRequest
from zitadel_client.models.user_service_register_passkey_response import UserServiceRegisterPasskeyResponse
from zitadel_client.models.user_service_register_totp_response import UserServiceRegisterTOTPResponse
from zitadel_client.models.user_service_register_u2_f_request import UserServiceRegisterU2FRequest
from zitadel_client.models.user_service_register_u2_f_response import UserServiceRegisterU2FResponse
from zitadel_client.models.user_service_remove_idp_link_response import UserServiceRemoveIDPLinkResponse
from zitadel_client.models.user_service_remove_otp_email_response import UserServiceRemoveOTPEmailResponse
from zitadel_client.models.user_service_remove_otpsms_response import UserServiceRemoveOTPSMSResponse
from zitadel_client.models.user_service_remove_passkey_response import UserServiceRemovePasskeyResponse
from zitadel_client.models.user_service_remove_phone_response import UserServiceRemovePhoneResponse
from zitadel_client.models.user_service_remove_totp_response import UserServiceRemoveTOTPResponse
from zitadel_client.models.user_service_remove_u2_f_response import UserServiceRemoveU2FResponse
from zitadel_client.models.user_service_resend_email_code_request import UserServiceResendEmailCodeRequest
from zitadel_client.models.user_service_resend_email_code_response import UserServiceResendEmailCodeResponse
from zitadel_client.models.user_service_resend_invite_code_response import UserServiceResendInviteCodeResponse
from zitadel_client.models.user_service_resend_phone_code_request import UserServiceResendPhoneCodeRequest
from zitadel_client.models.user_service_resend_phone_code_response import UserServiceResendPhoneCodeResponse
from zitadel_client.models.user_service_retrieve_identity_provider_intent_request import UserServiceRetrieveIdentityProviderIntentRequest
from zitadel_client.models.user_service_retrieve_identity_provider_intent_response import UserServiceRetrieveIdentityProviderIntentResponse
from zitadel_client.models.user_service_send_email_code_request import UserServiceSendEmailCodeRequest
from zitadel_client.models.user_service_send_email_code_response import UserServiceSendEmailCodeResponse
from zitadel_client.models.user_service_set_email_request import UserServiceSetEmailRequest
from zitadel_client.models.user_service_set_email_response import UserServiceSetEmailResponse
from zitadel_client.models.user_service_set_password_request import UserServiceSetPasswordRequest
from zitadel_client.models.user_service_set_password_response import UserServiceSetPasswordResponse
from zitadel_client.models.user_service_set_phone_request import UserServiceSetPhoneRequest
from zitadel_client.models.user_service_set_phone_response import UserServiceSetPhoneResponse
from zitadel_client.models.user_service_start_identity_provider_intent_request import UserServiceStartIdentityProviderIntentRequest
from zitadel_client.models.user_service_start_identity_provider_intent_response import UserServiceStartIdentityProviderIntentResponse
from zitadel_client.models.user_service_unlock_user_response import UserServiceUnlockUserResponse
from zitadel_client.models.user_service_update_human_user_request import UserServiceUpdateHumanUserRequest
from zitadel_client.models.user_service_update_human_user_response import UserServiceUpdateHumanUserResponse
from zitadel_client.models.user_service_verify_email_request import UserServiceVerifyEmailRequest
from zitadel_client.models.user_service_verify_email_response import UserServiceVerifyEmailResponse
from zitadel_client.models.user_service_verify_invite_code_request import UserServiceVerifyInviteCodeRequest
from zitadel_client.models.user_service_verify_invite_code_response import UserServiceVerifyInviteCodeResponse
from zitadel_client.models.user_service_verify_passkey_registration_request import UserServiceVerifyPasskeyRegistrationRequest
from zitadel_client.models.user_service_verify_passkey_registration_response import UserServiceVerifyPasskeyRegistrationResponse
from zitadel_client.models.user_service_verify_phone_request import UserServiceVerifyPhoneRequest
from zitadel_client.models.user_service_verify_phone_response import UserServiceVerifyPhoneResponse
from zitadel_client.models.user_service_verify_totp_registration_request import UserServiceVerifyTOTPRegistrationRequest
from zitadel_client.models.user_service_verify_totp_registration_response import UserServiceVerifyTOTPRegistrationResponse
from zitadel_client.models.user_service_verify_u2_f_registration_request import UserServiceVerifyU2FRegistrationRequest
from zitadel_client.models.user_service_verify_u2_f_registration_response import UserServiceVerifyU2FRegistrationResponse

from zitadel_client.api_client import ApiClient, RequestSerialized
from zitadel_client.api_response import ApiResponse
from zitadel_client.rest import RESTResponseType


class UserServiceApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def user_service_add_human_user(
    self,
      user_service_add_human_user_request: UserServiceAddHumanUserRequest,
    ) -> UserServiceAddHumanUserResponse:
        """Create a new human user

        Create/import a new user with the type human. The newly created user will get a verification email if either the email address is not marked as verified and you did not request the verification to be returned.

        :param user_service_add_human_user_request: (required)
        :type user_service_add_human_user_request: UserServiceAddHumanUserRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_add_human_user_serialize(
            user_service_add_human_user_request=user_service_add_human_user_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceAddHumanUserResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_add_human_user_serialize(
        self,
        user_service_add_human_user_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_add_human_user_request is not None:
            _body_params = user_service_add_human_user_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/human',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_add_idp_link(
    self,
      user_id: StrictStr,
      user_service_add_idp_link_request: UserServiceAddIDPLinkRequest,
    ) -> UserServiceAddIDPLinkResponse:
        """Add link to an identity provider to an user

        Add link to an identity provider to an user..

        :param user_id: (required)
        :type user_id: str
        :param user_service_add_idp_link_request: (required)
        :type user_service_add_idp_link_request: UserServiceAddIDPLinkRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_add_idp_link_serialize(
            user_id=user_id,
            user_service_add_idp_link_request=user_service_add_idp_link_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceAddIDPLinkResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_add_idp_link_serialize(
        self,
        user_id,
        user_service_add_idp_link_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_add_idp_link_request is not None:
            _body_params = user_service_add_idp_link_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/links',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_add_otp_email(
    self,
      user_id: StrictStr,
    ) -> UserServiceAddOTPEmailResponse:
        """Add OTP Email for a user

        Add a new One-Time Password (OTP) Email factor to the authenticated user. OTP Email will enable the user to verify a OTP with the latest verified email. The email has to be verified to add the second factor..

        :param user_id: (required)
        :type user_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_add_otp_email_serialize(
            user_id=user_id,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceAddOTPEmailResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_add_otp_email_serialize(
        self,
        user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/otp_email',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_add_otpsms(
    self,
      user_id: StrictStr,
    ) -> UserServiceAddOTPSMSResponse:
        """Add OTP SMS for a user

        Add a new One-Time Password (OTP) SMS factor to the authenticated user. OTP SMS will enable the user to verify a OTP with the latest verified phone number. The phone number has to be verified to add the second factor..

        :param user_id: (required)
        :type user_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_add_otpsms_serialize(
            user_id=user_id,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceAddOTPSMSResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_add_otpsms_serialize(
        self,
        user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/otp_sms',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_create_invite_code(
    self,
      user_id: StrictStr,
      user_service_create_invite_code_request: UserServiceCreateInviteCodeRequest,
    ) -> UserServiceCreateInviteCodeResponse:
        """Create an invite code for a user

        Create an invite code for a user to initialize their first authentication method (password, passkeys, IdP) depending on the organization's available methods. If an invite code has been created previously, it's url template and application name will be used as defaults for the new code. The new code will overwrite the previous one and make it invalid.

        :param user_id: (required)
        :type user_id: str
        :param user_service_create_invite_code_request: (required)
        :type user_service_create_invite_code_request: UserServiceCreateInviteCodeRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_create_invite_code_serialize(
            user_id=user_id,
            user_service_create_invite_code_request=user_service_create_invite_code_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceCreateInviteCodeResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_create_invite_code_serialize(
        self,
        user_id,
        user_service_create_invite_code_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_create_invite_code_request is not None:
            _body_params = user_service_create_invite_code_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/invite_code',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_create_passkey_registration_link(
    self,
      user_id: StrictStr,
      user_service_create_passkey_registration_link_request: UserServiceCreatePasskeyRegistrationLinkRequest,
    ) -> UserServiceCreatePasskeyRegistrationLinkResponse:
        """Create a passkey registration link for a user

        Create a passkey registration link which includes a code and either return it or send it to the user..

        :param user_id: (required)
        :type user_id: str
        :param user_service_create_passkey_registration_link_request: (required)
        :type user_service_create_passkey_registration_link_request: UserServiceCreatePasskeyRegistrationLinkRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_create_passkey_registration_link_serialize(
            user_id=user_id,
            user_service_create_passkey_registration_link_request=user_service_create_passkey_registration_link_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceCreatePasskeyRegistrationLinkResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_create_passkey_registration_link_serialize(
        self,
        user_id,
        user_service_create_passkey_registration_link_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_create_passkey_registration_link_request is not None:
            _body_params = user_service_create_passkey_registration_link_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/passkeys/registration_link',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_deactivate_user(
    self,
      user_id: StrictStr,
    ) -> UserServiceDeactivateUserResponse:
        """Deactivate user

        The state of the user will be changed to 'deactivated'. The user will not be able to log in anymore. The endpoint returns an error if the user is already in the state 'deactivated'. Use deactivate user when the user should not be able to use the account anymore, but you still need access to the user data..

        :param user_id: (required)
        :type user_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_deactivate_user_serialize(
            user_id=user_id,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceDeactivateUserResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_deactivate_user_serialize(
        self,
        user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/deactivate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_delete_user(
    self,
      user_id: StrictStr,
    ) -> UserServiceDeleteUserResponse:
        """Delete user

        The state of the user will be changed to 'deleted'. The user will not be able to log in anymore. Endpoints requesting this user will return an error 'User not found..

        :param user_id: (required)
        :type user_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_delete_user_serialize(
            user_id=user_id,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceDeleteUserResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_delete_user_serialize(
        self,
        user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v2/users/{userId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_get_user_by_id(
    self,
      user_id: Annotated[StrictStr, Field(description="User ID of the user you like to get.")],
    ) -> UserServiceGetUserByIDResponse:
        """User by ID

        Returns the full user object (human or machine) including the profile, email, etc..

        :param user_id: User ID of the user you like to get. (required)
        :type user_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_get_user_by_id_serialize(
            user_id=user_id,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceGetUserByIDResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_get_user_by_id_serialize(
        self,
        user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/users/{userId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_human_mfa_init_skipped(
    self,
      user_id: StrictStr,
    ) -> UserServiceHumanMFAInitSkippedResponse:
        """MFA Init Skipped

        Update the last time the user has skipped MFA initialization. The server timestamp is used.

        :param user_id: (required)
        :type user_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_human_mfa_init_skipped_serialize(
            user_id=user_id,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceHumanMFAInitSkippedResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_human_mfa_init_skipped_serialize(
        self,
        user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/mfa_init_skipped',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_list_authentication_factors(
    self,
      user_id: StrictStr,
      auth_factors: Annotated[Optional[List[StrictStr]], Field(description="Specify the Auth Factors you are interested in")] = None,
      states: Annotated[Optional[List[StrictStr]], Field(description="Specify the state of the Auth Factors")] = None,
    ) -> UserServiceListAuthenticationFactorsResponse:
        """user_service_list_authentication_factors


        :param user_id: (required)
        :type user_id: str
        :param auth_factors: Specify the Auth Factors you are interested in
        :type auth_factors: List[str]
        :param states: Specify the state of the Auth Factors
        :type states: List[str]
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_list_authentication_factors_serialize(
            user_id=user_id,
            auth_factors=auth_factors,
            states=states,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceListAuthenticationFactorsResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_list_authentication_factors_serialize(
        self,
        user_id,
        auth_factors,
        states,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'authFactors': 'csv',
            'states': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        if auth_factors is not None:
            
            _query_params.append(('authFactors', auth_factors))
            
        if states is not None:
            
            _query_params.append(('states', states))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/authentication_factors/_search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_list_authentication_method_types(
    self,
      user_id: StrictStr,
      domain_query_include_without_domain: Annotated[Optional[StrictBool], Field(description="List also auth method types without domain information like passkey and U2F added through V1 APIs / Login UI.")] = None,
      domain_query_domain: Annotated[Optional[StrictStr], Field(description="List only auth methods with specific domain.")] = None,
    ) -> UserServiceListAuthenticationMethodTypesResponse:
        """List all possible authentication methods of a user

        List all possible authentication methods of a user like password, passwordless, (T)OTP and more..

        :param user_id: (required)
        :type user_id: str
        :param domain_query_include_without_domain: List also auth method types without domain information like passkey and U2F added through V1 APIs / Login UI.
        :type domain_query_include_without_domain: bool
        :param domain_query_domain: List only auth methods with specific domain.
        :type domain_query_domain: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_list_authentication_method_types_serialize(
            user_id=user_id,
            domain_query_include_without_domain=domain_query_include_without_domain,
            domain_query_domain=domain_query_domain,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceListAuthenticationMethodTypesResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_list_authentication_method_types_serialize(
        self,
        user_id,
        domain_query_include_without_domain,
        domain_query_domain,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        if domain_query_include_without_domain is not None:
            
            _query_params.append(('domainQuery.includeWithoutDomain', domain_query_include_without_domain))
            
        if domain_query_domain is not None:
            
            _query_params.append(('domainQuery.domain', domain_query_domain))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/users/{userId}/authentication_methods',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_list_idp_links(
    self,
      user_id: StrictStr,
      user_service_list_idp_links_request: UserServiceListIDPLinksRequest,
    ) -> UserServiceListIDPLinksResponse:
        """List links to an identity provider of an user

        List links to an identity provider of an user.

        :param user_id: (required)
        :type user_id: str
        :param user_service_list_idp_links_request: (required)
        :type user_service_list_idp_links_request: UserServiceListIDPLinksRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_list_idp_links_serialize(
            user_id=user_id,
            user_service_list_idp_links_request=user_service_list_idp_links_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceListIDPLinksResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_list_idp_links_serialize(
        self,
        user_id,
        user_service_list_idp_links_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_list_idp_links_request is not None:
            _body_params = user_service_list_idp_links_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/links/_search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_list_passkeys(
    self,
      user_id: StrictStr,
    ) -> UserServiceListPasskeysResponse:
        """List passkeys of an user

        List passkeys of an user

        :param user_id: (required)
        :type user_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_list_passkeys_serialize(
            user_id=user_id,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceListPasskeysResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_list_passkeys_serialize(
        self,
        user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/passkeys/_search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_list_users(
    self,
      user_service_list_users_request: UserServiceListUsersRequest,
    ) -> UserServiceListUsersResponse:
        """Search Users

        Search for users. By default, we will return all users of your instance that you have permission to read. Make sure to include a limit and sorting for pagination.

        :param user_service_list_users_request: (required)
        :type user_service_list_users_request: UserServiceListUsersRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_list_users_serialize(
            user_service_list_users_request=user_service_list_users_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceListUsersResponse",
            '400': "UserServiceRpcStatus",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_list_users_serialize(
        self,
        user_service_list_users_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_list_users_request is not None:
            _body_params = user_service_list_users_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_lock_user(
    self,
      user_id: StrictStr,
    ) -> UserServiceLockUserResponse:
        """Lock user

        The state of the user will be changed to 'locked'. The user will not be able to log in anymore. The endpoint returns an error if the user is already in the state 'locked'. Use this endpoint if the user should not be able to log in temporarily because of an event that happened (wrong password, etc.)..

        :param user_id: (required)
        :type user_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_lock_user_serialize(
            user_id=user_id,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceLockUserResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_lock_user_serialize(
        self,
        user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/lock',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_password_reset(
    self,
      user_id: StrictStr,
      user_service_password_reset_request: UserServicePasswordResetRequest,
    ) -> UserServicePasswordResetResponse:
        """Request a code to reset a password

        Request a code to reset a password..

        :param user_id: (required)
        :type user_id: str
        :param user_service_password_reset_request: (required)
        :type user_service_password_reset_request: UserServicePasswordResetRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_password_reset_serialize(
            user_id=user_id,
            user_service_password_reset_request=user_service_password_reset_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServicePasswordResetResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_password_reset_serialize(
        self,
        user_id,
        user_service_password_reset_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_password_reset_request is not None:
            _body_params = user_service_password_reset_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/password_reset',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_reactivate_user(
    self,
      user_id: StrictStr,
    ) -> UserServiceReactivateUserResponse:
        """Reactivate user

        Reactivate a user with the state 'deactivated'. The user will be able to log in again afterward. The endpoint returns an error if the user is not in the state 'deactivated'..

        :param user_id: (required)
        :type user_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_reactivate_user_serialize(
            user_id=user_id,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceReactivateUserResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_reactivate_user_serialize(
        self,
        user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/reactivate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_register_passkey(
    self,
      user_id: StrictStr,
      user_service_register_passkey_request: UserServiceRegisterPasskeyRequest,
    ) -> UserServiceRegisterPasskeyResponse:
        """Start the registration of passkey for a user

        Start the registration of a passkey for a user, as a response the public key credential creation options are returned, which are used to verify the passkey..

        :param user_id: (required)
        :type user_id: str
        :param user_service_register_passkey_request: (required)
        :type user_service_register_passkey_request: UserServiceRegisterPasskeyRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_register_passkey_serialize(
            user_id=user_id,
            user_service_register_passkey_request=user_service_register_passkey_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceRegisterPasskeyResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_register_passkey_serialize(
        self,
        user_id,
        user_service_register_passkey_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_register_passkey_request is not None:
            _body_params = user_service_register_passkey_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/passkeys',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_register_totp(
    self,
      user_id: StrictStr,
    ) -> UserServiceRegisterTOTPResponse:
        """Start the registration of a TOTP generator for a user

        Start the registration of a TOTP generator for a user, as a response a secret returned, which is used to initialize a TOTP app or device..

        :param user_id: (required)
        :type user_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_register_totp_serialize(
            user_id=user_id,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceRegisterTOTPResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_register_totp_serialize(
        self,
        user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/totp',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_register_u2_f(
    self,
      user_id: StrictStr,
      user_service_register_u2_f_request: UserServiceRegisterU2FRequest,
    ) -> UserServiceRegisterU2FResponse:
        """Start the registration of a u2f token for a user

        Start the registration of a u2f token for a user, as a response the public key credential creation options are returned, which are used to verify the u2f token..

        :param user_id: (required)
        :type user_id: str
        :param user_service_register_u2_f_request: (required)
        :type user_service_register_u2_f_request: UserServiceRegisterU2FRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_register_u2_f_serialize(
            user_id=user_id,
            user_service_register_u2_f_request=user_service_register_u2_f_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceRegisterU2FResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_register_u2_f_serialize(
        self,
        user_id,
        user_service_register_u2_f_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_register_u2_f_request is not None:
            _body_params = user_service_register_u2_f_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/u2f',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_remove_idp_link(
    self,
      user_id: StrictStr,
      idp_id: StrictStr,
      linked_user_id: StrictStr,
    ) -> UserServiceRemoveIDPLinkResponse:
        """Remove link of an identity provider to an user

        Remove link of an identity provider to an user.

        :param user_id: (required)
        :type user_id: str
        :param idp_id: (required)
        :type idp_id: str
        :param linked_user_id: (required)
        :type linked_user_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_remove_idp_link_serialize(
            user_id=user_id,
            idp_id=idp_id,
            linked_user_id=linked_user_id,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceRemoveIDPLinkResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_remove_idp_link_serialize(
        self,
        user_id,
        idp_id,
        linked_user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        if idp_id is not None:
            _path_params['idpId'] = idp_id
        if linked_user_id is not None:
            _path_params['linkedUserId'] = linked_user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v2/users/{userId}/links/{idpId}/{linkedUserId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_remove_otp_email(
    self,
      user_id: StrictStr,
    ) -> UserServiceRemoveOTPEmailResponse:
        """Remove One-Time Password (OTP) Email from a user

        Remove the configured One-Time Password (OTP) Email factor of a user. As only one OTP Email per user is allowed, the user will not have OTP Email as a second factor afterward.

        :param user_id: (required)
        :type user_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_remove_otp_email_serialize(
            user_id=user_id,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceRemoveOTPEmailResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_remove_otp_email_serialize(
        self,
        user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v2/users/{userId}/otp_email',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_remove_otpsms(
    self,
      user_id: StrictStr,
    ) -> UserServiceRemoveOTPSMSResponse:
        """Remove One-Time Password (OTP) SMS from a user

        Remove the configured One-Time Password (OTP) SMS factor of a user. As only one OTP SMS per user is allowed, the user will not have OTP SMS as a second factor afterward.

        :param user_id: (required)
        :type user_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_remove_otpsms_serialize(
            user_id=user_id,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceRemoveOTPSMSResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_remove_otpsms_serialize(
        self,
        user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v2/users/{userId}/otp_sms',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_remove_passkey(
    self,
      user_id: StrictStr,
      passkey_id: StrictStr,
    ) -> UserServiceRemovePasskeyResponse:
        """Remove passkey from a user

        Remove passkey from a user.

        :param user_id: (required)
        :type user_id: str
        :param passkey_id: (required)
        :type passkey_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_remove_passkey_serialize(
            user_id=user_id,
            passkey_id=passkey_id,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceRemovePasskeyResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_remove_passkey_serialize(
        self,
        user_id,
        passkey_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        if passkey_id is not None:
            _path_params['passkeyId'] = passkey_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v2/users/{userId}/passkeys/{passkeyId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_remove_phone(
    self,
      user_id: StrictStr,
    ) -> UserServiceRemovePhoneResponse:
        """Delete the user phone

        Delete the phone number of a user.

        :param user_id: (required)
        :type user_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_remove_phone_serialize(
            user_id=user_id,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceRemovePhoneResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_remove_phone_serialize(
        self,
        user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v2/users/{userId}/phone',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_remove_totp(
    self,
      user_id: StrictStr,
    ) -> UserServiceRemoveTOTPResponse:
        """Remove TOTP generator from a user

        Remove the configured TOTP generator of a user. As only one TOTP generator per user is allowed, the user will not have TOTP as a second factor afterward.

        :param user_id: (required)
        :type user_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_remove_totp_serialize(
            user_id=user_id,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceRemoveTOTPResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_remove_totp_serialize(
        self,
        user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v2/users/{userId}/totp',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_remove_u2_f(
    self,
      user_id: StrictStr,
      u2f_id: StrictStr,
    ) -> UserServiceRemoveU2FResponse:
        """Remove u2f token from a user

        Remove u2f token from a user

        :param user_id: (required)
        :type user_id: str
        :param u2f_id: (required)
        :type u2f_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_remove_u2_f_serialize(
            user_id=user_id,
            u2f_id=u2f_id,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceRemoveU2FResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_remove_u2_f_serialize(
        self,
        user_id,
        u2f_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        if u2f_id is not None:
            _path_params['u2fId'] = u2f_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v2/users/{userId}/u2f/{u2fId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_resend_email_code(
    self,
      user_id: StrictStr,
      user_service_resend_email_code_request: UserServiceResendEmailCodeRequest,
    ) -> UserServiceResendEmailCodeResponse:
        """Resend code to verify user email

        Resend code to verify user email.

        :param user_id: (required)
        :type user_id: str
        :param user_service_resend_email_code_request: (required)
        :type user_service_resend_email_code_request: UserServiceResendEmailCodeRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_resend_email_code_serialize(
            user_id=user_id,
            user_service_resend_email_code_request=user_service_resend_email_code_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceResendEmailCodeResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_resend_email_code_serialize(
        self,
        user_id,
        user_service_resend_email_code_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_resend_email_code_request is not None:
            _body_params = user_service_resend_email_code_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/email/resend',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_resend_invite_code(
    self,
      user_id: StrictStr,
    ) -> UserServiceResendInviteCodeResponse:
        """(Deprecated) Resend an invite code for a user

        Deprecated: Use [CreateInviteCode](apis/resources/user_service_v2/user-service-create-invite-code.api.mdx) instead.  Resend an invite code for a user to initialize their first authentication method (password, passkeys, IdP) depending on the organization's available methods. A resend is only possible if a code has been created previously and sent to the user. If there is no code or it was directly returned, an error will be returned.

        :param user_id: (required)
        :type user_id: str
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("POST /v2/users/{userId}/invite_code/resend is deprecated.", DeprecationWarning)

        _param = self.__user_service_resend_invite_code_serialize(
            user_id=user_id,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceResendInviteCodeResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_resend_invite_code_serialize(
        self,
        user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/invite_code/resend',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_resend_phone_code(
    self,
      user_id: StrictStr,
      user_service_resend_phone_code_request: UserServiceResendPhoneCodeRequest,
    ) -> UserServiceResendPhoneCodeResponse:
        """Resend code to verify user phone

        Resend code to verify user phone.

        :param user_id: (required)
        :type user_id: str
        :param user_service_resend_phone_code_request: (required)
        :type user_service_resend_phone_code_request: UserServiceResendPhoneCodeRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_resend_phone_code_serialize(
            user_id=user_id,
            user_service_resend_phone_code_request=user_service_resend_phone_code_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceResendPhoneCodeResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_resend_phone_code_serialize(
        self,
        user_id,
        user_service_resend_phone_code_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_resend_phone_code_request is not None:
            _body_params = user_service_resend_phone_code_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/phone/resend',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_retrieve_identity_provider_intent(
    self,
      idp_intent_id: Annotated[StrictStr, Field(description="ID of the idp intent, previously returned on the success response of the IDP callback")],
      user_service_retrieve_identity_provider_intent_request: UserServiceRetrieveIdentityProviderIntentRequest,
    ) -> UserServiceRetrieveIdentityProviderIntentResponse:
        """Retrieve the information returned by the identity provider

        Retrieve the information returned by the identity provider for registration or updating an existing user with new information..

        :param idp_intent_id: ID of the idp intent, previously returned on the success response of the IDP callback (required)
        :type idp_intent_id: str
        :param user_service_retrieve_identity_provider_intent_request: (required)
        :type user_service_retrieve_identity_provider_intent_request: UserServiceRetrieveIdentityProviderIntentRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_retrieve_identity_provider_intent_serialize(
            idp_intent_id=idp_intent_id,
            user_service_retrieve_identity_provider_intent_request=user_service_retrieve_identity_provider_intent_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceRetrieveIdentityProviderIntentResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_retrieve_identity_provider_intent_serialize(
        self,
        idp_intent_id,
        user_service_retrieve_identity_provider_intent_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if idp_intent_id is not None:
            _path_params['idpIntentId'] = idp_intent_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_retrieve_identity_provider_intent_request is not None:
            _body_params = user_service_retrieve_identity_provider_intent_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/idp_intents/{idpIntentId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_send_email_code(
    self,
      user_id: StrictStr,
      user_service_send_email_code_request: UserServiceSendEmailCodeRequest,
    ) -> UserServiceSendEmailCodeResponse:
        """Send code to verify user email

        Send code to verify user email.

        :param user_id: (required)
        :type user_id: str
        :param user_service_send_email_code_request: (required)
        :type user_service_send_email_code_request: UserServiceSendEmailCodeRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_send_email_code_serialize(
            user_id=user_id,
            user_service_send_email_code_request=user_service_send_email_code_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceSendEmailCodeResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_send_email_code_serialize(
        self,
        user_id,
        user_service_send_email_code_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_send_email_code_request is not None:
            _body_params = user_service_send_email_code_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/email/send',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_set_email(
    self,
      user_id: StrictStr,
      user_service_set_email_request: UserServiceSetEmailRequest,
    ) -> UserServiceSetEmailResponse:
        """Change the user email

        Change the email address of a user. If the state is set to not verified, a verification code will be generated, which can be either returned or sent to the user by email..

        :param user_id: (required)
        :type user_id: str
        :param user_service_set_email_request: (required)
        :type user_service_set_email_request: UserServiceSetEmailRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_set_email_serialize(
            user_id=user_id,
            user_service_set_email_request=user_service_set_email_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceSetEmailResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_set_email_serialize(
        self,
        user_id,
        user_service_set_email_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_set_email_request is not None:
            _body_params = user_service_set_email_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/email',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_set_password(
    self,
      user_id: StrictStr,
      user_service_set_password_request: UserServiceSetPasswordRequest,
    ) -> UserServiceSetPasswordResponse:
        """Change password

        Change the password of a user with either a verification code or the current password..

        :param user_id: (required)
        :type user_id: str
        :param user_service_set_password_request: (required)
        :type user_service_set_password_request: UserServiceSetPasswordRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_set_password_serialize(
            user_id=user_id,
            user_service_set_password_request=user_service_set_password_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceSetPasswordResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_set_password_serialize(
        self,
        user_id,
        user_service_set_password_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_set_password_request is not None:
            _body_params = user_service_set_password_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/password',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_set_phone(
    self,
      user_id: StrictStr,
      user_service_set_phone_request: UserServiceSetPhoneRequest,
    ) -> UserServiceSetPhoneResponse:
        """Set the user phone

        Set the phone number of a user. If the state is set to not verified, a verification code will be generated, which can be either returned or sent to the user by sms..

        :param user_id: (required)
        :type user_id: str
        :param user_service_set_phone_request: (required)
        :type user_service_set_phone_request: UserServiceSetPhoneRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_set_phone_serialize(
            user_id=user_id,
            user_service_set_phone_request=user_service_set_phone_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceSetPhoneResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_set_phone_serialize(
        self,
        user_id,
        user_service_set_phone_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_set_phone_request is not None:
            _body_params = user_service_set_phone_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/phone',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_start_identity_provider_intent(
    self,
      user_service_start_identity_provider_intent_request: UserServiceStartIdentityProviderIntentRequest,
    ) -> UserServiceStartIdentityProviderIntentResponse:
        """Start flow with an identity provider

        Start a flow with an identity provider, for external login, registration or linking..

        :param user_service_start_identity_provider_intent_request: (required)
        :type user_service_start_identity_provider_intent_request: UserServiceStartIdentityProviderIntentRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_start_identity_provider_intent_serialize(
            user_service_start_identity_provider_intent_request=user_service_start_identity_provider_intent_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceStartIdentityProviderIntentResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_start_identity_provider_intent_serialize(
        self,
        user_service_start_identity_provider_intent_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_start_identity_provider_intent_request is not None:
            _body_params = user_service_start_identity_provider_intent_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/idp_intents',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_unlock_user(
    self,
      user_id: StrictStr,
    ) -> UserServiceUnlockUserResponse:
        """Unlock user

        The state of the user will be changed to 'locked'. The user will not be able to log in anymore. The endpoint returns an error if the user is already in the state 'locked'. Use this endpoint if the user should not be able to log in temporarily because of an event that happened (wrong password, etc.)..

        :param user_id: (required)
        :type user_id: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_unlock_user_serialize(
            user_id=user_id,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceUnlockUserResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_unlock_user_serialize(
        self,
        user_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/unlock',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_update_human_user(
    self,
      user_id: StrictStr,
      user_service_update_human_user_request: UserServiceUpdateHumanUserRequest,
    ) -> UserServiceUpdateHumanUserResponse:
        """Update User

        Update all information from a user..

        :param user_id: (required)
        :type user_id: str
        :param user_service_update_human_user_request: (required)
        :type user_service_update_human_user_request: UserServiceUpdateHumanUserRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_update_human_user_serialize(
            user_id=user_id,
            user_service_update_human_user_request=user_service_update_human_user_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceUpdateHumanUserResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_update_human_user_serialize(
        self,
        user_id,
        user_service_update_human_user_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_update_human_user_request is not None:
            _body_params = user_service_update_human_user_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/v2/users/human/{userId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_verify_email(
    self,
      user_id: StrictStr,
      user_service_verify_email_request: UserServiceVerifyEmailRequest,
    ) -> UserServiceVerifyEmailResponse:
        """Verify the email

        Verify the email with the generated code.

        :param user_id: (required)
        :type user_id: str
        :param user_service_verify_email_request: (required)
        :type user_service_verify_email_request: UserServiceVerifyEmailRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_verify_email_serialize(
            user_id=user_id,
            user_service_verify_email_request=user_service_verify_email_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceVerifyEmailResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_verify_email_serialize(
        self,
        user_id,
        user_service_verify_email_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_verify_email_request is not None:
            _body_params = user_service_verify_email_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/email/verify',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_verify_invite_code(
    self,
      user_id: StrictStr,
      user_service_verify_invite_code_request: UserServiceVerifyInviteCodeRequest,
    ) -> UserServiceVerifyInviteCodeResponse:
        """Verify an invite code for a user

        Verify the invite code of a user previously issued. This will set their email to a verified state and allow the user to set up their first authentication method (password, passkeys, IdP) depending on the organization's available methods.

        :param user_id: (required)
        :type user_id: str
        :param user_service_verify_invite_code_request: (required)
        :type user_service_verify_invite_code_request: UserServiceVerifyInviteCodeRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_verify_invite_code_serialize(
            user_id=user_id,
            user_service_verify_invite_code_request=user_service_verify_invite_code_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceVerifyInviteCodeResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_verify_invite_code_serialize(
        self,
        user_id,
        user_service_verify_invite_code_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_verify_invite_code_request is not None:
            _body_params = user_service_verify_invite_code_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/invite_code/verify',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_verify_passkey_registration(
    self,
      user_id: StrictStr,
      passkey_id: StrictStr,
      user_service_verify_passkey_registration_request: UserServiceVerifyPasskeyRegistrationRequest,
    ) -> UserServiceVerifyPasskeyRegistrationResponse:
        """Verify a passkey for a user

        Verify the passkey registration with the public key credential..

        :param user_id: (required)
        :type user_id: str
        :param passkey_id: (required)
        :type passkey_id: str
        :param user_service_verify_passkey_registration_request: (required)
        :type user_service_verify_passkey_registration_request: UserServiceVerifyPasskeyRegistrationRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_verify_passkey_registration_serialize(
            user_id=user_id,
            passkey_id=passkey_id,
            user_service_verify_passkey_registration_request=user_service_verify_passkey_registration_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceVerifyPasskeyRegistrationResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_verify_passkey_registration_serialize(
        self,
        user_id,
        passkey_id,
        user_service_verify_passkey_registration_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        if passkey_id is not None:
            _path_params['passkeyId'] = passkey_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_verify_passkey_registration_request is not None:
            _body_params = user_service_verify_passkey_registration_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/passkeys/{passkeyId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_verify_phone(
    self,
      user_id: StrictStr,
      user_service_verify_phone_request: UserServiceVerifyPhoneRequest,
    ) -> UserServiceVerifyPhoneResponse:
        """Verify the phone

        Verify the phone with the generated code..

        :param user_id: (required)
        :type user_id: str
        :param user_service_verify_phone_request: (required)
        :type user_service_verify_phone_request: UserServiceVerifyPhoneRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_verify_phone_serialize(
            user_id=user_id,
            user_service_verify_phone_request=user_service_verify_phone_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceVerifyPhoneResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_verify_phone_serialize(
        self,
        user_id,
        user_service_verify_phone_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_verify_phone_request is not None:
            _body_params = user_service_verify_phone_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/phone/verify',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_verify_totp_registration(
    self,
      user_id: StrictStr,
      user_service_verify_totp_registration_request: UserServiceVerifyTOTPRegistrationRequest,
    ) -> UserServiceVerifyTOTPRegistrationResponse:
        """Verify a TOTP generator for a user

        Verify the TOTP registration with a generated code..

        :param user_id: (required)
        :type user_id: str
        :param user_service_verify_totp_registration_request: (required)
        :type user_service_verify_totp_registration_request: UserServiceVerifyTOTPRegistrationRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_verify_totp_registration_serialize(
            user_id=user_id,
            user_service_verify_totp_registration_request=user_service_verify_totp_registration_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceVerifyTOTPRegistrationResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_verify_totp_registration_serialize(
        self,
        user_id,
        user_service_verify_totp_registration_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_verify_totp_registration_request is not None:
            _body_params = user_service_verify_totp_registration_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/totp/verify',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def user_service_verify_u2_f_registration(
    self,
      user_id: StrictStr,
      u2f_id: StrictStr,
      user_service_verify_u2_f_registration_request: UserServiceVerifyU2FRegistrationRequest,
    ) -> UserServiceVerifyU2FRegistrationResponse:
        """Verify a u2f token for a user

        Verify the u2f token registration with the public key credential..

        :param user_id: (required)
        :type user_id: str
        :param u2f_id: (required)
        :type u2f_id: str
        :param user_service_verify_u2_f_registration_request: (required)
        :type user_service_verify_u2_f_registration_request: UserServiceVerifyU2FRegistrationRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__user_service_verify_u2_f_registration_serialize(
            user_id=user_id,
            u2f_id=u2f_id,
            user_service_verify_u2_f_registration_request=user_service_verify_u2_f_registration_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserServiceVerifyU2FRegistrationResponse",
            '403': "UserServiceRpcStatus",
            '404': "UserServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __user_service_verify_u2_f_registration_serialize(
        self,
        user_id,
        u2f_id,
        user_service_verify_u2_f_registration_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if user_id is not None:
            _path_params['userId'] = user_id
        if u2f_id is not None:
            _path_params['u2fId'] = u2f_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if user_service_verify_u2_f_registration_request is not None:
            _body_params = user_service_verify_u2_f_registration_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/users/{userId}/u2f/{u2fId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


