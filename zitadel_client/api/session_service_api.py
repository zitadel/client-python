# coding: utf-8

"""
    Zitadel SDK

    The Zitadel SDK is a convenience wrapper around the Zitadel APIs to assist you in integrating with your Zitadel environment. This SDK enables you to handle resources, settings, and configurations within the Zitadel platform.

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictStr
from typing import Optional
from typing_extensions import Annotated
from zitadel_client.models.session_service_create_session_request import SessionServiceCreateSessionRequest
from zitadel_client.models.session_service_create_session_response import SessionServiceCreateSessionResponse
from zitadel_client.models.session_service_delete_session_request import SessionServiceDeleteSessionRequest
from zitadel_client.models.session_service_delete_session_response import SessionServiceDeleteSessionResponse
from zitadel_client.models.session_service_get_session_response import SessionServiceGetSessionResponse
from zitadel_client.models.session_service_list_sessions_request import SessionServiceListSessionsRequest
from zitadel_client.models.session_service_list_sessions_response import SessionServiceListSessionsResponse
from zitadel_client.models.session_service_set_session_request import SessionServiceSetSessionRequest
from zitadel_client.models.session_service_set_session_response import SessionServiceSetSessionResponse

from zitadel_client.api_client import ApiClient, RequestSerialized
from zitadel_client.api_response import ApiResponse
from zitadel_client.rest import RESTResponseType


class SessionServiceApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def session_service_create_session(
    self,
      session_service_create_session_request: SessionServiceCreateSessionRequest,
    ) -> SessionServiceCreateSessionResponse:
        """Create a new session

        Create a new session. A token will be returned, which is required for further updates of the session.

        :param session_service_create_session_request: (required)
        :type session_service_create_session_request: SessionServiceCreateSessionRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__session_service_create_session_serialize(
            session_service_create_session_request=session_service_create_session_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "SessionServiceCreateSessionResponse",
            '403': "SessionServiceRpcStatus",
            '404': "SessionServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __session_service_create_session_serialize(
        self,
        session_service_create_session_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if session_service_create_session_request is not None:
            _body_params = session_service_create_session_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/sessions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def session_service_delete_session(
    self,
      session_id: Annotated[StrictStr, Field(description="\"id of the session to terminate\"")],
      session_service_delete_session_request: SessionServiceDeleteSessionRequest,
    ) -> SessionServiceDeleteSessionResponse:
        """Terminate an existing session

        Terminate your own session or if granted any other session.

        :param session_id: \"id of the session to terminate\" (required)
        :type session_id: str
        :param session_service_delete_session_request: (required)
        :type session_service_delete_session_request: SessionServiceDeleteSessionRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__session_service_delete_session_serialize(
            session_id=session_id,
            session_service_delete_session_request=session_service_delete_session_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SessionServiceDeleteSessionResponse",
            '403': "SessionServiceRpcStatus",
            '404': "SessionServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __session_service_delete_session_serialize(
        self,
        session_id,
        session_service_delete_session_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if session_service_delete_session_request is not None:
            _body_params = session_service_delete_session_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/v2/sessions/{sessionId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def session_service_get_session(
    self,
      session_id: StrictStr,
      session_token: Optional[StrictStr] = None,
    ) -> SessionServiceGetSessionResponse:
        """Get a session

        Get a session and all its information like the time of the user or password verification

        :param session_id: (required)
        :type session_id: str
        :param session_token:
        :type session_token: str
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__session_service_get_session_serialize(
            session_id=session_id,
            session_token=session_token,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SessionServiceGetSessionResponse",
            '403': "SessionServiceRpcStatus",
            '404': "SessionServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __session_service_get_session_serialize(
        self,
        session_id,
        session_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        if session_token is not None:
            
            _query_params.append(('sessionToken', session_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/sessions/{sessionId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def session_service_list_sessions(
    self,
      session_service_list_sessions_request: SessionServiceListSessionsRequest,
    ) -> SessionServiceListSessionsResponse:
        """Search sessions

        Search for sessions

        :param session_service_list_sessions_request: (required)
        :type session_service_list_sessions_request: SessionServiceListSessionsRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__session_service_list_sessions_serialize(
            session_service_list_sessions_request=session_service_list_sessions_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SessionServiceListSessionsResponse",
            '400': "SessionServiceRpcStatus",
            '403': "SessionServiceRpcStatus",
            '404': "SessionServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __session_service_list_sessions_serialize(
        self,
        session_service_list_sessions_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if session_service_list_sessions_request is not None:
            _body_params = session_service_list_sessions_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v2/sessions/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def session_service_set_session(
    self,
      session_id: Annotated[StrictStr, Field(description="\"id of the session to update\"")],
      session_service_set_session_request: SessionServiceSetSessionRequest,
    ) -> SessionServiceSetSessionResponse:
        """Update an existing session

        Update an existing session with new information.

        :param session_id: \"id of the session to update\" (required)
        :type session_id: str
        :param session_service_set_session_request: (required)
        :type session_service_set_session_request: SessionServiceSetSessionRequest
        :return: Returns the result object.
        """ # noqa: E501

        _param = self.__session_service_set_session_serialize(
            session_id=session_id,
            session_service_set_session_request=session_service_set_session_request,
            _request_auth=None,
            _content_type=None,
            _headers=None,
            _host_index=0
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SessionServiceSetSessionResponse",
            '403': "SessionServiceRpcStatus",
            '404': "SessionServiceRpcStatus",
        }

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=None
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    def __session_service_set_session_serialize(
        self,
        session_id,
        session_service_set_session_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if session_id is not None:
            _path_params['sessionId'] = session_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if session_service_set_session_request is not None:
            _body_params = session_service_set_session_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'zitadelAccessToken'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/v2/sessions/{sessionId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


